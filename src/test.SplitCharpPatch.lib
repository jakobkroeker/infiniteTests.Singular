

option("redSB");

echo = 1;
LIB("primdec.lib");
LIB("ehv.lib");
LIB("randomIdeal.lib");

proc splitCharpNew(list l)
{
  if((char(basering)==0)||(npars(basering)>0))
  {
    return(l);
  }
  def op = option(get);
  def P=basering;
  int i,j,k,m,q,d,o;
  int n = nvars(basering);
  ASSUME(0, n>1); //otherwise code while(va[j]!=","){j--;} will fail!
  ideal s,t,u,sact;
  poly ni;
  string minp,gnir,va;
  list sa,keep,rp,keep1;
  for(i=1;i<=size(l) div 2;i++)
  {
    if(size(l[2*i])==0)
    {
      if(deg(l[2*i-1][1])==vdim(l[2*i-1]))
      {
        l[2*i]=l[2*i-1];
      }
    }
  }
  for(i=1;i<=size(l) div 2;i++)
  {
    if(size(l[2*i])==0)
    {
      s=factorize(l[2*i-1][1],1);   //vermeiden!!!
      t=l[2*i-1];
      m=size(t);
      ni=s[1];
      if(deg(ni)>1)
      {
        va=varstr(P);
        j=size(va);

        while(va[j]!=","){j--;}
        va=va[1..j-1];
        // ugly, but no variable conflicts. jk
        gnir="ring RL=("+string(char(P))+","+string(var(n))+"),("+va+"),lp;";
        execute(gnir);
        minpoly=leadcoef(imap(P,ni));
        ideal act;
        ideal t=imap(P,t);

        for(k=2;k<=m;k++)
        {
          act=factorize(t[k],1);
          if(size(act)>1){break;}
        }
        setring P;
        sact=imap(RL,act);

        if(size(sact)>1)
        {
          sa=sat1(l[2*i-1],sact[1]);
          keep[size(keep)+1]=std(l[2*i-1],sa[2]);
          l[2*i-1]=std(sa[1]);
          l[2*i]=primaryTest(sa[1],sa[1][1]);
        }
        if((size(sact)==1)&&(m==2))
        {
          l[2*i]=l[2*i-1];
          attrib(l[2*i],"isSB",1);
        }
        if((size(sact)==1)&&(m>2))
        {
          setring RL;

          option(redSB);
          t=std(t);

          list sp=zero_decomp(t,0,0);

          setring P;
          rp=imap(RL,sp);
          for(o=1;o<=size(rp);o++)
          {
            rp[o]=interred(simplify(rp[o],1)+ideal(ni));
          }
          l[2*i-1]=rp[1];
          l[2*i]=rp[2];
          rp=delete(rp,1);
          rp=delete(rp,1);
          keep1=keep1+rp;

          option(noredSB);
        }
        kill RL;
      }
    }
  }
  if(size(keep)>0)
  {
    for(i=1;i<=size(keep);i++)
    {
      if(deg(keep[i][1])>0)
      {
        l[size(l)+1]=keep[i];
        l[size(l)+1]=primaryTest(keep[i],keep[i][1]);
      }
    }
  }
  l=l+keep1;
  option(set,op);
  return(l);
}



proc splitCharpOrig(list l)
{
  if((char(basering)==0)||(npars(basering)>0))
  {
    return(l);
  }
  def op = option(get);
  def P=basering;
  int i,j,k,m,q,d,o;
  int n = nvars(basering);
  ideal s,t,u,sact;
  poly ni;
  string minp,gnir,va;
  list sa,keep,rp,keep1;
  for(i=1;i<=size(l) div 2;i++)
  {
    if(size(l[2*i])==0)
    {
      if(deg(l[2*i-1][1])==vdim(l[2*i-1]))
      {
        l[2*i]=l[2*i-1];
      }
    }
  }
  for(i=1;i<=size(l) div 2;i++)
  {
    if(size(l[2*i])==0)
    {
      s=factorize(l[2*i-1][1],1);   //vermeiden!!!
      t=l[2*i-1];
      m=size(t);
      ni=s[1];
      if(deg(ni)>1)
      {
        va=varstr(P);
        j=size(va);
        while(va[j]!=","){j--;}
        va=va[1..j-1];
        gnir="ring RL=("+string(char(P))+","+string(var(n))+"),("+va+"),lp;";
        execute(gnir);
        minpoly=leadcoef(imap(P,ni));
        ideal act;
        ideal t=imap(P,t);

        for(k=2;k<=m;k++)
        {
          act=factorize(t[k],1);
          if(size(act)>1){break;}
        }
        setring P;
        sact=imap(RL,act);

        if(size(sact)>1)
        {
          sa=sat1(l[2*i-1],sact[1]);
          keep[size(keep)+1]=std(l[2*i-1],sa[2]);
          l[2*i-1]=std(sa[1]);
          l[2*i]=primaryTest(sa[1],sa[1][1]);
        }
        if((size(sact)==1)&&(m==2))
        {
          l[2*i]=l[2*i-1];
          attrib(l[2*i],"isSB",1);
        }
        if((size(sact)==1)&&(m>2))
        {
          setring RL;

          option(redSB);
          t=std(t);

          list sp=zero_decomp(t,0,0);

          setring P;
          rp=imap(RL,sp);
          for(o=1;o<=size(rp);o++)
          {
            rp[o]=interred(simplify(rp[o],1)+ideal(ni));
          }
          l[2*i-1]=rp[1];
          l[2*i]=rp[2];
          rp=delete(rp,1);
          rp=delete(rp,1);
          keep1=keep1+rp;

          option(noredSB);
        }
        kill RL;
      }
    }
  }
  if(size(keep)>0)
  {
    for(i=1;i<=size(keep);i++)
    {
      if(deg(keep[i][1])>0)
      {
        l[size(l)+1]=keep[i];
        l[size(l)+1]=primaryTest(keep[i],keep[i][1]);
      }
    }
  }
  l=l+keep1;
  option(set,op);
  return(l);
}

proc testPatchedSplitCharp(  pRng ,idealGen, trials )
{
    print ("testPatchedSplitCharp");
    if (defined(basering) ) {   def BAS=basering; }

    //def splitCharpStr=string(Primdec::splitCharp);
    kill Primdec::splitCharp;

    setring pRng;

    int trial;
    list L1,L2;
    ideal I;
    for (trial = 1; trial<=trials; trial++)
    {   
       setring pRng;
       print ("trial: "+string(trial));
      
       I = idealGen();
       print ("I:");
       I;
       if (not idealsEqual(I,ideal(0)) && not idealsEqual(ideal(1),I ) )
       {
            if ( defined(splitCharp) ) { kill splitCharp; }
            proc splitCharp(list l) 
            {
               return (splitCharpOrig(l));
            } 
            export(splitCharp);
            L1 = primdecGTZ(I);
            if (defined(splitCharp)) { kill splitCharp; }
            //proc splitCharp = splitCharpStr;
            proc splitCharp(list l) 
            {
               return (splitCharpNew(l));
            } 
            export(splitCharp);
            L2 = primdecGTZ(I);
            ASSUME(0, primDecsAreEquivalent(L1, L2) );

            testPrimary( L1, I );
       }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}


proc testPatchedSplitCharpWrapper(cchar,cord)
{
      init_randomIdeal();
      string cmd = "ring rng ="+cchar+" ,(x,y,z),"+cord+";";
      execute(cmd);
          
      def genParams = defaultIdealGeneratorParams();
      // adjust random ideal generator params:
      genParams.maxGens=4; 
      genParams.absMaxCoeff = 15;
      genParams.maxMonomialDegree = 3;
      genParams.maxTermsPerGen = 4;
      genParams.maxGens = 4;

      def idealG = idealGeneratorFromParams( genParams  );

      int trials = 3000;
      testPatchedSplitCharp( rng, idealG, trials);
}

testPatchedSplitCharpWrapper("7","dp");
testPatchedSplitCharpWrapper("7","lp"); 
testPatchedSplitCharpWrapper("7","Dp");
testPatchedSplitCharpWrapper("5","dp");
testPatchedSplitCharpWrapper("5","lp");
testPatchedSplitCharpWrapper("5","Dp");

testPatchedSplitCharpWrapper("19","dp");
testPatchedSplitCharpWrapper("19","lp");
testPatchedSplitCharpWrapper("19","Dp");



