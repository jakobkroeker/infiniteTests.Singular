

option("redSB");

LIB("ringutils.lib");
LIB("wrappers.lib");
LIB("reslipman.lib");
LIB("randomIdeal.lib");


proc testLipmanResolve( rng, idealG, trials)
{
    print ("testResolve");
    if (defined(basering) ) {   def BAS=basering; }


    setring rng;
    export(rng);

    int trial;
    ideal I,J;
    int dbg;
    list occuringVariableData;
    list L;
    for (trial = 1; trial<=trials; )
    {   
       setring rng;

       J = idealG();
       //dbprint( 1, "J:", J, "" );
       I =  idealG();
       //dbprint( 1, "I:", I, "" );
       
       I = I+J;
       I = Radical(I);
       I = std(I);
       //dbprint( 1, "I:", I, "" );

      if (not isZero(I) && not idealsAreEqual(ideal(1), I) )
      {
           dbg = printlevel - voice + 2;
         //--- eliminate unnecessary variables from the ambient space 
           
           occuringVariableData = findvars(I,0);
           if ( size(occuringVariableData[1]) > 0 ) 
           {
               if ( defined(Rnew) )  { kill Rnew; }
               execute(" ring Rnew = ("+charstr(rng)+"), ("+string( occuringVariableData[1] )+"), dp; ");
               dbprint( 1, "rnew:", Rnew, "" );
               ideal I = imap(rng,I);
               I = Radical(I);
               I = std(I);

               if (    dimIdeal(I)==2 && ( not isZero(I) ) && ( not idealsAreEqual(ideal(1), I) )    )
               {
                   print ( "trial: "+string(trial) );
                   dbprint( 1, "basering:", basering, "" );
                   dbprint( 1, "I:", I, "" );
                   dbprint( 1, "call lipmanresolve", "" );
                   trial = trial+1;
                   L = lipmanresolve(I);
                   L; 
               }
           }
       }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}



proc testResolverapper(cchar, cord )
{
    def genParams = defaultIdealGeneratorParams();

    // adjust random ideal generator params:
 
    genParams.absMaxCoeff = 15;
    genParams.maxMonomialDegree = 3;
    genParams.maxTermsPerGen = 2;
    genParams.maxGens = 3;

    def idealG = idealGeneratorFromParams( genParams  );

	// seems doable
	int numVars = 3;
	int trials = 10000;

    def rng = createRing(cchar,cord, numVars) ;


	testLipmanResolve( rng, idealG,  trials);
}


def assumeLevel = 3;
echo = 2;

printlevel = 3 ;
TRACE = 0;

testResolverapper("0", "dp" );
testResolverapper("0", "lp" );

testResolverapper("integer", "dp" );
testResolverapper("integer", "lp" );

 











