
echo = 1;


LIB("ringutils.lib");
LIB("primdec.lib");
LIB("wrappers.lib");

proc idealsEqual( ideal k, ideal j)
{
  return(Primdec::stdIdealsEqual(groebner(k),groebner(j)));
}


proc testIdealsEqual( numVars, maxGens, absMaxCoeff, maxMonomialDegree, maxTermsPerGen, trials , pordstr)
{
    print ("testResolve");
    if (defined(basering) ) {   def BAS=basering; }

    def rng = createRing("0",pordstr, numVars) ;
    setring rng;
    export(rng);

    list ideals;

    int trial;
    for (trial = 1; trial<=trials; trial++)
    {   
       setring rng;
       //print ("trial: "+string(trial));
       if ( defined(j) ) { kill j; }
       ideal j = randomIdeal(  random(1, maxGens) , random(1, absMaxCoeff) , random(0, maxMonomialDegree), random(1, maxTermsPerGen)  );
       //print ("j:");
       //j;
       if ( defined(i) ) { kill i; }
       ideal i = randomIdeal(  random(1, maxGens) , random(1, absMaxCoeff) , random(0, maxMonomialDegree), random(1, maxTermsPerGen)  );
       //print ("i:");
       //i;
       
       if (idealsEqual(i,j))
       {
            print("idealsEqual");
            ASSUME(0, idealsAreEqual(i,j));
       }
       else
       {
           print("idealsNOTEqual");
            ASSUME(0, not idealsAreEqual(i,j));
       }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}


proc testIdealsEqualWrapper()
{
	printlevel = 0 ;
    TRACE = 0;
	// seems doable
	int numVars = 3;
	int maxGens = 5;
	int maxTermsPerGen = 4;
	int maxMonomialDegree = 3;
	int absMaxCoeff = 15 ;
	int trials = 1000;
	testIdealsEqual( numVars, maxGens, absMaxCoeff, maxMonomialDegree, maxTermsPerGen, trials, "lp");
}

testIdealsEqualWrapper();

