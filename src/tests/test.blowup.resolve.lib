/////////////////////
version="version test.blowup2.resolve.lib";
category="Commutative Algebra";
info="
";

LIB("primdec.lib");
LIB("ringutils.lib");
LIB("wrappers.lib");
LIB("resolve.lib");

proc testBlowUp2( getRng, gens, trialsPerRing, ol  )
{

    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
    def rng = getRng( );
    setring rng;
    option(warn);
    short = 0;
    int trial;

    while(1)
    {
        option(nowarn);  
        kill rng;   
        if (defined(basering) ) {   def BAS=basering; }

        def rng = getRng() ;
        setring rng;    

        ideal I, J;       

        if (warnIsSet)       {        option(warn);      }
        
        ol.clearX();
        ol.writeX( "");
        ol.writeX( "");
        
        ol.writeX( "LIB \"wrappers.lib\";");
        ol.writeX( "LIB \"src/randomRing.lib\" ;");
        ol.writeX( "LIB \"src/tests/test.blowup2.resolve.lib\" ;");
        
        ol.writeX(  ringToStringHack (basering) );
        
        I = gens.idealG( );
        J = gens.idealG( );            
            
        ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
        ol.writeX( "ideal I = " + string( I ) + ";" );
        ol.writeX( "  ol.writeX( \"ideal I = \" + string( I ) + \";\" );" );
        ol.writeX( "ideal J = " + string( J ) + ";" );
        ol.writeX( "  ol.writeX( \"ideal J = \" + string( J ) + \";\" );" );
        
        ol.writeX("  I = I+J; ");     
        I = I+J;
        if (dimIdeal(I)>=0)
        {
            ol.writeX("  blowUp2(J,I); ");     
            blowUp2(J,I);
        }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}

/*
proc testBlowUp2rapper()
{
	printlevel = 0 ;
    TRACE=1;
	// seems doable
	int numVars = 3;
	int maxGens = 5;
	int maxTermsPerGen = 5;
	int maxMonomialDegree = 5;
	int absMaxCoeff = 105;
	int trials = 1000;
	testBlowUp2( numVars, maxGens, absMaxCoeff, maxMonomialDegree, maxTermsPerGen, trials);
}

testBlowUp2rapper();
*/

