/////////////////////
version="version test.normalZ_primeideal.lib";
category="Commutative Algebra";
info="
";



LIB("primdec.lib");
LIB("ringutils.lib");
LIB("wrappers.lib");
LIB("reslipman.lib");



proc testNormalZ_primeidealCrash( getRng, inputG, trialsPerRing, ol  )
{
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
    def rng = getRng( );
    setring rng;
    option(warn);    
    int trial;

    list ideals;

    int trial;
    int npos;
   
    def L, L1, L2 ;

   
    def testResult;
    int printlevelOffset = 3 ; // required, since otherwise normal() prints dbinfo because it increases printlevel

    trial = 0;
    while(1)
    {   
    
        option(nowarn);  
        kill rng;      

        ol.writeX( " // getRng() ;");

        def rng = getRng( );
        setring rng;
        
        if (warnIsSet)      {        option(warn);      }
        

        
   
       if ( defined(I) ) { kill I; }
       ideal I = inputG();
  
      
        
     
       if  (   idealsAreEqual(ideal(1), I)   )     {          continue;       }
       
       def L = primdecZ(I);             

       for (npos=1; npos <= size(L); npos++)
       {
            ol.clearX();
            ol.writeX( "");
            ol.writeX( "");
            
            ol.writeX( "LIB \"wrappers.lib\";");
            ol.writeX( "LIB \"src/randomRing.lib\" ;");
            ol.writeX( "LIB \"src/tests/test.normalZ_primeideal.lib\" ;"); 
            ol.writeX(  ringToStringHack (basering) );
            ol.writeX( "int trial = " + string( trial) + ";" );        
        
           I = L[npos][2];
           
           ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
           ol.writeX( "ideal I = " + string( I ) + ";" );
           // ol.writeX( "  ol.writeX( \"ideal I = \" + string( I ) + \";\" );" );
           
            ol.writeX( "   ASSUME(0, isPrime(I) );");
            ASSUME(0, isPrime(I) );
            
 
           if (isPrime(j) && (not idealContainsConstants(j))  && (not isZero(j)) && (not idealsAreEqual( ideal(1), j ) )   )
           {
               if (not idealsAreEqual( ideal(1), testideal(j) ))
                {            
                   if (defined(L1)) {kill L1;}
                   
                   ol.writeX( " def L1 = normalZ_primeideal(I);");
                       
                   def L1 = normalZ_primeideal(I);
                   trial = trial+1;
              }
           }
       }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}

 





