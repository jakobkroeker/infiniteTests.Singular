/////
version="version test.normal.lib";
category="Commutative Algebra";
info="
";





proc testNormalTemplate( testeeInfo, getRandomRing, gens, optionlist, trialsPerRing,  resultCheckerInfo, ol);
{
    def testee     = testeeInfo.testee;
    def testeeName = testeeInfo.testeeName;
    
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
    def rng = getRandomRing(gens);
    setring rng;
    option(warn);
      
    short = 0;
    int trial = 0 ;

    int npos;
 
    def testResult;
    int printlevelOffset = 3 ; // required, since otherwise normal() prints dbinfo because it increases printlevel

    while( 1 )
    {   
        option(nowarn);       
      
        kill rng;      
        def rng = getRandomRing(gens);
        setring rng;
        short = 0;
           
       if ( hasGlobalOrdering(basering))
       {
          chooseRandomOptionsFromList(optionlist);
       }
       if (warnIsSet)    {      option(warn);     }
       
       if ( defined(J) ) { kill J; }
       ideal J = gens.idealG();      
       
       if  ( idealsAreEqual(ideal(1), J)   )    {     continue;    }
 
       ol.clearX();
       ol.writeX( "");
       ol.writeX( "");


       ol.writeX( " intvec testResult; ");
       ol.writeX( "int voiceLvl = "+string(voice)+";");
       
       ol.writeX( "LIB(\"normal.lib\");");
       ol.writeX( "LIB(\"src/wrappers.lib\");");
       ol.writeX( "LIB(\"src/randomRing.lib\");");
          ol.writeX( "LIB(\"src/test/test.normal.lib\");");
       ol.writeX(  ringToStringHack (basering) );
       ol.writeX( "int trial ;");
       ol.writeX( "ideal J ="+string(J)+";" );

       ol.writeX( "def L = primdecGTZ(J);");
       def L = primdecGTZ(J);
       ol.writeX( "ASSUME(0, testPrimary(L,J) ); ");
       ASSUME(0, testPrimary(L,J) );
       
       ol.writeX( "ideal component;");

       if ( defined(component) ) { kill component; }
       ideal component;   
      
       if ( defined(normalResult) ) { kill normalResult; }
       ol.writeX( "list normalResult;");
       list normalResult;
          
       for ( npos=1; npos<=size(L); npos++ )
       {
           ol.writeX( "component   = L["+string(npos)+"][2];");
           component = L[npos][2];

           ol.writeX( string(option()));
           
           ol.writeX( " ASSUME(0, isPrime(component) );" );
           ASSUME(0, isPrime(component) );
 
           if (isPrime(component) && (not isZero(component)) && (not idealsAreEqual(ideal(1),component)) && (not idealsAreEqual(ideal(1),slocus(component) ))  )
           {
               trial = trial+1;
               ol.writeX( "trial = "+string(trial)+";");

               ol.writeX( "normalResult = "+testeeName(component) );
               normalResult = testee(component);
               ol.writeX( " resultCheckerInfo.resultCheckerName(component, normalResult);");
               resultCheckerInfo.resultChecker(component, normalResult);                                    
           }
       }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}

proc normalResultChecker(result,input)
{
    list L = norTest(input,result);
    ASSUME(0, L == [1,1,1]);        
}

proc testeeNormal(ideal I)
{
    return normal(I,"withRing");
}


    
proc testNormal ( getRandomRing, gens, optionlist, trialsPerRing, ol);
{
    TesteeInfo testeeInfo;
    testeeinfo.testee = testeeNormal;
    testeeinfo.testeeName = "testeeNormal";
    
    ResultCheckInfo resultCheckerInfo;
    resultCheckerInfo.resultChecker = normalResultChecker;
    resultCheckerInfo.resultCheckerName = "normalResultChecker";
  
    testNormalTemplate( testeeInfo, getRandomRing, gens, optionlist, trialsPerRing, resultChecker,ol);
}

proc testeeNormalP(ideal I)
{
    return normalP(I,"withRing");
}
    
    
proc testNormalP ( getRandomRing, gens, optionlist, trialsPerRing, ol);
{
    TesteeInfo testeeInfo;
    testeeinfo.testee = testeeNormalP;
    testeeinfo.testeeName = "testeeNormalP";
    
    ResultCheckInfo resultCheckerInfo;
    resultCheckerInfo.resultChecker = normalResultChecker;
    resultCheckerInfo.resultCheckerName = "normalResultChecker";
    
    testNormalTemplate( testeeInfo, getRandomRing, gens, optionlist, trialsPerRing,  resultCheckerInfo, ol);   
    
}


