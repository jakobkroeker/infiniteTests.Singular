/////////////////////
version="version test.intersect.vs.intersectZ";
category="Commutative Algebra";
info="
";


LIB "primdecint.lib";
LIB "randomRing.lib";
 

proc testIntersect( getRng, idealG, trials, ol )
{
    int warnIsSet = optionIsSet("warn");
    def rng = getRng( );
    setring rng;
    option(warn);
    if (defined(basering) ) {   def BAS=basering; }
    setring rng;

    int trial;
    ideal cs,  I, J;

    while( trial<trials )
    {   
       option(nowarn);  
       def rng = getRng( );
       setring rng;
       if (warnIsSet)       {        option(warn);      }
     
       ol.clearX();
       ol.writeX( "");
       ol.writeX( "");
       ol.writeX( "LIB \"primdec.lib\";");
       ol.writeX( "LIB \"wrappers.lib\";");
       ol.writeX( "LIB \"src/randomRing.lib\" ;");
       ol.writeX(  ringToStringHack (basering) );
       ol.writeX( "int trial = " + string( trial) + ";" );
       short = 0;
       
       I = idealG( );
       J = idealG( );
       
       
       ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
       ol.writeX( "ideal I = " + string( I ) + ";" );
       ol.writeX( "  ol.writeX( \"ideal I = \" + string( I ) + \";\" );" );
       
       ol.writeX( "ideal J = " + string( J ) + ";" );
       ol.writeX( "  ol.writeX( \"ideal J = \" + string( J ) + \";\" );" );
       
       
       ol.writeX( "  intersect(I,J);" );
       intersect(I,J);
       ol.writeX( "  intersectZ(I,J);" );
       intersectZ(I,J);
       ol.writeX( "    ASSUME(0, idealsAreEqual( intersect(I,J), intersectZ(I,J) ) );" );
       ASSUME(0, idealsAreEqual( intersect(I,J), intersectZ(I,J) ) );
       trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}
	

