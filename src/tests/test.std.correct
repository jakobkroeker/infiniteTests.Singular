/////////////////////
version="version test.std";
category="Commutative Algebra";
info="
";

LIB "primdecint.lib";
LIB "randomideal.lib";
LIB "ringutils.lib";
LIB "wrappers.lib";
 
 
static proc mod_init()
{
    if (not defined(TGroebnerTestFlag_def) )
    {
        int TGroebnerTestFlag_def = 0;
        newstruct("TGroebnerTestFlags",   " int reduceTest, int repeatApplication,  int equalTest, int optionflagTest, int testIntersect");   
    }
    
     if (not defined(TGroebnerTestInput_def) )
    {
        int TGroebnerTestInput_def = 0;
        newstruct("TGroebnerTestInput",   " ideal I, ideal J, poly p");   
    }
    
    if (not defined(TGroebnerTestResult_def) )
    {
        int TGroebnerTestResult_def = 0;
        newstruct("TGroebnerTestResult",   " ideal gI, ideal gIJ, ideal gI_J, ideal gIp, ideal gI_p");   
    }
    
    if (not defined(TGroebnerTestResultPair_def) )
    {
        int TGroebnerTestResultPair_def = 0;
        newstruct("TGroebnerTestResultPair",   " TGroebnerTestResult result1, TGroebnerTestResult result2");   
    }
}

proc defaultGroebnerTestFlags()
{
  TGroebnerTestFlags flags;
  flags.reduceTest = 1;
  flags.repeatApplication = 1;
  flags.equalTest = 1;
  flags.optionflagTest = 1;
  flags.testIntersect = 0;
  return (flags);
}

// pairList: (result computation, list of testing routines)
// but then: how combine (or not combine?)

// construct input and result generation depending on tests ? (later. basic variant: generate complete input)


proc computeResultStd(TGroebnerTestInput input)
{
    TGroebnerTestResult result;
    
    result.gI  = std(input.I);
    result.gIJ  = std(input.I + input.J);
    result.gI_J = std(input.I, input.J);    
    result.gIp = std(input.I + input.p);
    result.gI_p = std(input.I, input.p);
    
    return(result);  
}

proc computeResultGroebner(TGroebnerTestInput input)
{
    TGroebnerTestResult result;
    
    result.gI   = groebner(input.I);
    result.gIJ  = groebner(input.I + input.J);
    result.gI_J = groebner(input.I, input.J);    
    result.gIp  = groebner(input.I + input.p);
    result.gI_p = groebner(input.I, input.p);
    
    return(result);  
}


proc reducesToZero(result,input)
{
   ASSUME (  0, 0==size( reduce(input.I, result.gI ) )  );
}


proc equalTest(result,input)
{
    ASSUME (  0,  idealsAreEqual(result.gI, input.I)  );
}



proc coeffIntegrityCheck(result,input)
{
     if (hasIntegerCoefficientRing(basering))
     {                   
          testLeadCoeffsNotNegative(result.gI);
     }
}

 
proc resultIsFixpoint(result1,result2)
{
    ASSUME (  0,  idealsAreEqual(result1.gI, result2.gI)  );    
}

proc resultSizeIsFixpoint(result1, result2, input)
{
    ASSUME (  0,  size(result1.gI)==size(result2.gI)  );
}


proc checkAppendIdeal(result,input)
{
     ASSUME (  0,  size(result.gIJ)==size(result.gI_J)  );     
     ASSUME (  0,  idealsAreEqual(result.gIJ, result.gI_J)  );
}

proc checkAppendPolynomial(result,input)
{
     ASSUME (  0,  size(result.gIp)==size(result.gI_p)  );     
     ASSUME (  0,  idealsAreEqual(result.gIp, result.gI_p)  );
}

proc checkReducedTail(result,input)
{
      if ( hasGlobalOrdering(basering)  )
      {  
          if ( optionIsSet("redSB") )
          {
               
                ol.writeX("  // idealRepresentationReducedTail(result.gI);");
                if (not idealRepresentationReducedTail(result.gI ) )
                {
                   ol.writeX( "//        gI : "+string(result.gI) );
                   ASSUME(0, "not idealRepresentationReducedTail");
                }
          }
      }
}
               
               

proc testIntersect(result,input)
{    
      ASSUME(0, idealsAreEqual( intersect(input.J,   input.I),  intersect(result.gJ, result.gI)  ) );      
      ASSUME(0, idealsAreEqual( intersect(input.I,   input.J),  intersect(result.gJ, result.gI)  ) );      
      ASSUME(0, idealsAreEqual( intersect(result.gI, input.J),  intersect(input.J,   result.gI)  ) );
}

proc testLeadCoeffsNotNegative(gI)
{
    int k;
        for(k=1; k <= ncols(gI); k++)
        {
             ASSUME(0, (leadcoef(gI[k]) >= 0));
        }
}



// testeeInfo.testee: std or groebner (what about sba??)
// testeeInfo.testeeName: "std" or "groebner"


proc testPureGroebner( testeeInfo, getRng, gens, optionlist, trialsPerSameRing, TGroebnerTestFlags testflags, finished, ol )
{
    def testeeName = testeeInfo.name;
    
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
      def rng = getRng( );
      setring rng;
      option(warn);
      
    short = 0;
    int trial;
    string cmd ;
    while( not finished(trial) )
    {   
      option(nowarn);  
      kill rng;      

      ol.writeX( " // getRng() ;");

      def rng = getRng( );
      setring rng;
      ideal cs,  I, J, gI, gJ, ggI, ggJ;

      // todo: fkt getOptions() einf√ºhren bzw 
      if (testflags.optionflagTest)
      {
        if ( hasGlobalOrLocalOrdering(basering))
        {
           chooseRandomOptionsFromList(optionlist);
        }
      }
      if (warnIsSet)
      {
        option(warn);
      }
      
      
       if (defined(qrng)) {kill qrng; }
       ol.clearX();
       ol.writeX( "");
       ol.writeX( "");
      
       ol.writeX( "LIB \"wrappers.lib\";");
       ol.writeX( "LIB \"src/randomRing.lib\" ;");
       ol.writeX( "LIB \"src/tests/test.std.correct\" ;"); 
       ol.writeX(  ringToStringHack (basering) );
       ol.writeX( "  ideal cs,  I, J, gI, gJ, ggI, ggJ;");
       ol.writeX( "int trial = " + string( trial) + ";" );
       short = 0;
       I = gens.idealG( );
       ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
       ol.writeX( "I = " + string( I ) + ";" );
       ol.writeX( "  ol.writeX( \"I = \" + string( I ) + \";\" );" );
       
       cmd = "       gI =  "+testeeName+"(I);";
       ol.writeX( cmd);
       execute(cmd);
       //ol.writeX( "//        gI = "+string(gI) );
     

      if (hasIntegerCoefficientRing(basering))
      {          
          ol.writeX( "    testLeadCoeffsNotNegative(gI);" );
          testLeadCoeffsNotNegative(gI);
      }
     
       
       if (testflags.reduceTest)
       {
            cmd = "ASSUME(0, 0== size( "+testeeName+"(reduce (I,gI ) ))  );";
            ol.writeX( cmd);
            execute(cmd);
       }
       
        if (testflags.equalTest)
        {

           ol.writeX("ASSUME(0, idealsAreEqual(I,gI ));");
           ASSUME(0, idealsAreEqual(I,gI ));  

           /*

              if ( hasGlobalOrdering(basering) or hasLocalOrdering(basering) )
              {        
           
                   ol.writeX("ASSUME(0, idealsEqual(I,gI ));");
                   ASSUME(0, idealsEqual(I,gI ));
              }
           */

       }
       //if ( hasGlobalOrdering(basering))
       //{

       //}
       
       if (testflags.repeatApplication)
       { 
            cmd = "        ggI =  "+testeeName+"(gI);" ;
            ol.writeX(cmd);
            execute(cmd);
            
            ol.writeX( "//  hasIntegerCoefficientRing(basering); ");
            if (hasIntegerCoefficientRing(basering))
            {
                ol.writeX( " testLeadCoeffsNotNegative(ggI);" );
                testLeadCoeffsNotNegative(ggI);
            }

            if (testflags.equalTest)
            {
                ol.writeX("ASSUME(0, idealsAreEqual(gI,ggI ));");
                ASSUME(0, idealsAreEqual(gI,ggI ));

                /*
                if ( hasGlobalOrdering(basering) or hasLocalOrdering(basering) )
                {
                        ol.writeX("ASSUME(0, idealsEqual(gI,ggI ));");
                        ASSUME(0, idealsEqual(gI,ggI ));
                }

                */


            }
      }

     if (not testflags.optionflagTest)
     {
        continue;
     }
      // if ( hasGlobalOrdering(basering) or hasLocalOrdering(basering) )
      ol.writeX("  // hasGlobalOrdering(basering);");
      if ( hasGlobalOrdering(basering)  )
      {
  
          if ( optionIsSet("redSB") )
          {
               
                ol.writeX("  // idealRepresentationReducedTail(gI);");
                if (not idealRepresentationReducedTail(gI ) )
                {
                   ol.writeX( "//        gI = "+string(gI) );
                }
               

               ol.writeX("ASSUME(0, idealRepresentationReducedTail( gI ));");
               ASSUME(0, idealRepresentationReducedTail( gI ));
               


               ol.writeX("ASSUME(0, idealRepresentationReduced( gI ));");
               ASSUME(0, idealRepresentationReduced( gI ));
               
               
               if (testflags.repeatApplication)
               { 
       
                   ol.writeX("ASSUME(0, size(gI)== size(ggI) );");
                   ASSUME(0, size(gI)== size(ggI) );

                  ol.writeX("  // idealRepresentationReducedTail(ggI);");
                  if (not idealRepresentationReducedTail(ggI ) )
                  {
                     ol.writeX( "//        ggI = "+string(ggI) +";");
                  }
                  
                  
                 ol.writeX("ASSUME(0, idealRepresentationReduced( ggI ));");
                 ASSUME(0, idealRepresentationReduced( ggI ));
               
                
                  ol.writeX("ASSUME(0, idealRepresentationReducedTail( ggI ));");
                  ASSUME(0, idealRepresentationReducedTail( ggI ));
             }
             
         

          }

      }


       trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}


proc testGroebner( testeeInfo, ringG, gens, optionlist, trialsPerSameRing, testflags, finished, ol )
{
    def testeeName = testeeInfo.name;
    string cmd;
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
      def rng = ringG( );
      setring rng;
      option(warn);
      
    short = 0;
    int trial;

    while( not finished(trial) )
    {   
        option(nowarn);  
        kill rng;      
        def rng = ringG( );
        setring rng;
        ideal cs,  I, J, gI, gJ, ggI, ggJ;


        if (testflags.optionflagTest)
        {
            if ( hasGlobalOrLocalOrdering(basering))
            {
                chooseRandomOptionsFromList(optionlist);
            }
        }
        if (warnIsSet)        {            option(warn);        }
      

        if ( defined(qrng) ) {    kill qrng; }
        ol.clearX();
        ol.writeX( "");
        ol.writeX( "");
        ol.writeX( "LIB \"primdec.lib\";");
        ol.writeX( "LIB \"wrappers.lib\";");
        ol.writeX( "LIB \"src/randomRing.lib\" ;");
        ol.writeX( "LIB \"src/tests/test.std.correct\" ;");
        ol.writeX(  ringToStringHack (basering) );
        ol.writeX( "int trial = " + string( trial) + ";" );
        short = 0;
        I = gens.idealG( );
        J = gens.idealG( );
        ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
        ol.writeX( " ideal cs,  I, J, gI, gJ, ggI, ggJ;");
        ol.writeX( "ideal I = " + string( I ) + ";" );
        ol.writeX( "ideal J = " + string( J ) + ";" );

        cmd = "    gI =  "+testeeName+"(I);";
        ol.writeX( cmd );
        execute(cmd);
        //ol.writeX( "//        gI = "+string(gI) );

        cmd = "    gJ =  "+testeeName+"(J);";
        ol.writeX(cmd  );
        execute(cmd);      
        //ol.writeX( "//        gJ = "+string(gJ)+";" );
        if (hasIntegerCoefficientRing(basering))
        {
            ol.writeX( " testLeadCoeffsNotNegative(gI);" );
            ol.writeX( "    testLeadCoeffsNotNegative(gJ);" );
            testLeadCoeffsNotNegative(gI);
            testLeadCoeffsNotNegative(gJ);
        }
       
        if (testflags.reduceTest)
        {
            cmd = "ASSUME(0, 0== size( "+testeeName+"(reduce (I,gI ) ))  );";
            ol.writeX( cmd);
            execute(cmd);

                cmd =  "ASSUME(0, 0== size( "+testeeName+"(reduce (J,gJ ) ))  );";
                ol.writeX(cmd);
                execute(cmd);
        }
       
        if (testflags.equalTest)
        {
           ol.writeX("ASSUME(0, idealsAreEqual(I,gI ));");
           ASSUME(0, idealsAreEqual(I,gI ));

           ol.writeX("ASSUME(0, idealsAreEqual(J,gJ ));");
           ASSUME(0, idealsAreEqual(J,gJ ));
           
           
           ol.writeX("ASSUME(0, idealsEqual(I,gI ));");
           ASSUME(0, idealsEqual(I,gI ));

           ol.writeX("ASSUME(0, idealsEqual(J,gJ ));");
           ASSUME(0, idealsEqual(J,gJ ));
       }
       //if ( hasGlobalOrdering(basering))
       //{

       //}
       
        if (testflags.repeatApplication)
        { 
            cmd =  "  ggI =  "+testeeName+"(gI);";
            ol.writeX( cmd );
            execute(cmd);
            //ol.writeX( "//        ggI = "+string(ggI) +";");
            
            cmd =  "    ggJ =  "+testeeName+"(gJ);";
            ol.writeX( cmd );
            execute(cmd);
            //ol.writeX( "//        ggJ = "+string(ggJ)+";" );


            if (testflags.equalTest)
            {
                ol.writeX("ASSUME(0, idealsAreEqual(gI,ggI ));");
                ASSUME(0, idealsAreEqual(gI,ggI ));

                ol.writeX("ASSUME(0, idealsAreEqual(gJ,ggJ ));");
                ASSUME(0, idealsAreEqual(gJ,ggJ ));
                
                
                ol.writeX("ASSUME(0, idealsEqual(gI,ggI ));");
                ASSUME(0, idealsEqual(gI,ggI ));

                ol.writeX("ASSUME(0, idealsEqual(gJ,ggJ ));");
                ASSUME(0, idealsEqual(gJ,ggJ ));
            }
        }

        if (not testflags.optionflagTest)
        {
            continue;
        }
        if ( hasGlobalOrdering(basering))
        {
  
            if ( optionIsSet("redSB") )
            {
               
                if (not idealRepresentationReducedTail(gI ) )
                {
                    ol.writeX( "//        gI = "+string(gI) );
                }

                if (not idealRepresentationReducedTail(gJ ) )
                {
                    ol.writeX( "//        gJ = "+string(gJ) );
                }

                ol.writeX("ASSUME(0, idealRepresentationReducedTail( gI ));");
                ASSUME(0, idealRepresentationReducedTail( gI ));

                ol.writeX("ASSUME(0, idealRepresentationReducedTail( gJ ));");
                ASSUME(0, idealRepresentationReducedTail( gJ ));


                ol.writeX("ASSUME(0, idealRepresentationReduced( gI ));");
                ASSUME(0, idealRepresentationReduced( gI ));
                ol.writeX("ASSUME(0, idealRepresentationReduced( gJ ));");
                ASSUME(0, idealRepresentationReduced( gJ ));

            
                if (testflags.repeatApplication)
                { 
       
                    ol.writeX("ASSUME(0, size(gJ)== size(ggJ) );");
                    ASSUME(0, size(gJ)== size(ggJ) );

                    ol.writeX("ASSUME(0, size(gI)== size(ggI) );");
                    ASSUME(0, size(gI)== size(ggI) );

                    if (not idealRepresentationReducedTail(ggI ) )
                    {
                        ol.writeX( "//        ggI = "+string(ggI) +";");
                    }

                    if (not idealRepresentationReducedTail(ggJ ) )
                    {
                        ol.writeX( "//        ggJ = "+string(ggJ) +";");
                    }
                  
                    ol.writeX("ASSUME(0, idealRepresentationReducedTail( ggJ ));");
                    ASSUME(0, idealRepresentationReducedTail( ggJ ));
                    ol.writeX("ASSUME(0, idealRepresentationReduced( ggI ));");
                    ASSUME(0, idealRepresentationReduced( ggI ));
                    ol.writeX("ASSUME(0, idealRepresentationReduced( ggJ ));");
                    ASSUME(0, idealRepresentationReduced( ggJ ));
               
                
                    ol.writeX("ASSUME(0, idealRepresentationReducedTail( ggI ));");
                    ASSUME(0, idealRepresentationReducedTail( ggI ));
                }
             
                /* 
                ol.writeX("ASSUME(0, idealRepresentationsEqual(gI,ggI ));");
                ASSUME(0, idealRepresentationsEqual(gI,ggI ));
                ol.writeX("ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));");
                ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));
                */         
          }

      }
   


        if (testflags.testIntersect)
        {
            ol.writeX( "ASSUME(0, idealsEqual(intersect(I,J),intersect(gI,gJ) ) );");
            ASSUME(0, idealsEqual(intersect(I,J),intersect(gI,gJ) ) );

            ol.writeX("ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,gI) ) );");
            ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,gI) ) );

            ol.writeX("ASSUME(0, idealsAreEqual(intersect(I,J),intersect(gI,gJ) ) );");
            ASSUME(0, idealsAreEqual(intersect(I,J),intersect(gI,gJ) ) );

            ol.writeX("ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,gI) ) );");
            ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,gI) ) );


        }

       trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}

 

	 
proc testGroebnerAppend( testeeInfo, ringG, gens, optionlist, trials, testflags, finished, ol )
{  
    def testeeName = testeeInfo.name;
    
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
      def rng = ringG( );
      setring rng;
      option(warn);
      
    short = 0;
    int trial;
    string cmd;

    while( not finished(trial) )
    {   
      option(nowarn);  
      kill rng;      
      def rng = ringG( );
      setring rng;
      ideal cs,  I, J, gI, IJ, gIJ, gI_J, Ip, gIp, gI_p; 
      poly p ;

      if ( hasGlobalOrLocalOrdering(basering))
      {
         chooseRandomOptionsFromList(optionlist);
      }
      if (warnIsSet)
      {
        option(warn);
      }
      
      
       if (defined(qrng)) {kill qrng; }
       ol.clearX();
       ol.writeX( "");
       ol.writeX( "");
       ol.writeX( "LIB \"primdec.lib\";");
       ol.writeX( "LIB \"wrappers.lib\";");
       ol.writeX( "LIB \"src/randomRing.lib\" ;");
       ol.writeX(  ringToStringHack (basering) );
       ol.writeX( "int trial = " + string( trial) + ";" );
       short = 0;
       I = gens.idealG( );
       J = gens.idealG( );
       p = gens.polyG();
       ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
       ol.writeX( "ideal I = " + string( I ) + ";" );
       ol.writeX( "ideal J = " + string( J ) + ";" );
       ol.writeX( "poly p = " + string( p ) + ";" );
       
       ol.writeX( "  ideal cs,  I, J,gI,IJ, gIJ, gI_J, Ip, gIp, gI_p; ");
       
       cmd = "     gI   =  "+testeeName+"(I);";
       ol.writeX( cmd );       
       execute(cmd);
       
       ol.writeX( "     IJ   = I+J;");       
       IJ = I+J;
       
       cmd = "     gIJ  = "+testeeName+"(IJ);";       
       ol.writeX( cmd );
       execute(cmd);
       
       cmd =  "     gI_J = "+testeeName+"(gI,J);";
       ol.writeX( cmd);
       execute(cmd);
              
       ol.writeX( "     Ip   = I+p;");
       Ip = I+p;


       cmd =   "     gIp  = "+testeeName+"(Ip);";
       ol.writeX( cmd);
       execute(cmd);
       
       cmd =  "     gI_p = "+testeeName+"(gI,p);";
       ol.writeX( cmd);
       execute(cmd);
                          
          if (hasIntegerCoefficientRing(basering))
          {
              ol.writeX( "    testLeadCoeffsNotNegative(gI);" );
              ol.writeX( "    testLeadCoeffsNotNegative(gIp);" );
              ol.writeX( "    testLeadCoeffsNotNegative(gIJ);" );
              ol.writeX( "    testLeadCoeffsNotNegative(gI_p);" );

              testLeadCoeffsNotNegative(gI);
              testLeadCoeffsNotNegative(gIp);
              testLeadCoeffsNotNegative(gIJ);
              testLeadCoeffsNotNegative(gI_p);
          }


       if (testflags.reduceTest)
       {
           cmd = "ASSUME(0, 0== size( "+testeeName+"(reduce (I,gI ) ))  );";
           ol.writeX( cmd);
           execute(cmd);


           cmd =  " ASSUME(0, 0== size( "+testeeName+"(reduce (IJ,gIJ ) ))  ); ";
           ol.writeX( cmd);
           execute(cmd);

           cmd =  " ASSUME(0, 0== size( "+testeeName+"(reduce (IJ,gI_J ) ))  );" ;
           ol.writeX( cmd);
           execute(cmd);
      
            cmd =   "ASSUME(0, 0== size( "+testeeName+"(reduce (gI_J, gIJ) ))  ); " ;
           ol.writeX( cmd);
           execute(cmd);
           
           cmd =   " ASSUME(0, 0== size( "+testeeName+"(reduce (Ip,gIp ) ))  ); ";
           ol.writeX( cmd);
           execute(cmd);

           cmd =   " ASSUME(0, 0== size( "+testeeName+"(reduce (Ip,gI_p ) ))  );";
           ol.writeX( cmd);
           execute(cmd);

           cmd =   "ASSUME(0, 0== size( "+testeeName+"(reduce (gI_p, gIp) ))  ); ";
           ol.writeX( cmd);
           execute(cmd);          
       }


       
       
        if (testflags.equalTest)
        {
        
             //if ( hasGlobalOrdering(basering))
             //{

             ol.writeX("ASSUME(0, idealsEqual(gI_J,gIJ ));");
             ASSUME(0, idealsEqual(gI_J,gIJ ));

             ol.writeX("ASSUME(0, idealsEqual(gIJ, gI_J));");
             ASSUME(0, idealsEqual(gIJ, gI_J ));

            ol.writeX("ASSUME(0, idealsEqual(gI_p,gIp ));");
             ASSUME(0, idealsEqual(gI_p,gIp ));

             ol.writeX("ASSUME(0, idealsEqual(gIp, gI_p));");
             ASSUME(0, idealsEqual(gIp, gI_p ));

             //}
       
       }


     if (not testflags.optionflagTest)
     {
        continue;
     }
     
      if ( hasGlobalOrdering(basering))
      {
  
          if ( optionIsSet("redSB") )
          {
 
                ol.writeX("ASSUME(0, size(gI_J)== size(gIJ) );");
                ASSUME(0, size(gI_J)== size(gIJ)  );

                ol.writeX("ASSUME(0, size(gI_p)== size(gIp) );");
                ASSUME(0, size(gI_p)== size(gIp)  );



                if (not idealRepresentationReducedTail(gI ) )
                {
                   ol.writeX( "//        gI = "+string(gI) );
                }
                if (not idealRepresentationReducedTail(gIJ ) )
                {
                   ol.writeX( "//        gIJ = "+string(gIJ) +";");
                }
                if (not idealRepresentationReducedTail(gI_J ) )
                {
                   ol.writeX( "//        gI_J = "+string(gI_J) );
                }

                if (not idealRepresentationReducedTail(gIp ) )
                {
                   ol.writeX( "//        gIp = "+string(gIp) +";");
                }
                if (not idealRepresentationReducedTail(gI_p ) )
                {
                   ol.writeX( "//        gI_p = "+string(gI_p) );
                }

 

               ol.writeX("ASSUME(0, idealRepresentationReducedTail( gI ));");
               ASSUME(0, idealRepresentationReducedTail( gI ));
               ol.writeX("ASSUME(0, idealRepresentationReducedTail( gIJ ));");
               ASSUME(0, idealRepresentationReducedTail( gIJ ));
               
               ol.writeX("ASSUME(0, idealRepresentationReducedTail( gI_J ));");
               ASSUME(0, idealRepresentationReducedTail( gI_J ));

               ol.writeX("ASSUME(0, idealRepresentationReducedTail( gIp ));");
               ASSUME(0, idealRepresentationReducedTail( gIp ));
               
               ol.writeX("ASSUME(0, idealRepresentationReducedTail( gI_p ));");
               ASSUME(0, idealRepresentationReducedTail( gI_p ));

            
               ol.writeX("ASSUME(0, idealRepresentationReduced( gI ));");
               ASSUME(0, idealRepresentationReduced( gI ));
               ol.writeX("ASSUME(0, idealRepresentationReduced( gIJ ));");
               ASSUME(0, idealRepresentationReduced( gIJ ));
               ol.writeX("ASSUME(0, idealRepresentationReduced( gI_J ));");
               ASSUME(0, idealRepresentationReduced( gI_J ));

               ol.writeX("ASSUME(0, idealRepresentationReduced( gIp ));");
               ASSUME(0, idealRepresentationReduced( gIp ));
               ol.writeX("ASSUME(0, idealRepresentationReduced( gI_p ));");
               ASSUME(0, idealRepresentationReduced( gI_p ));

 
          }

      }


   /*
       ol.writeX("ASSUME(0, idealRepresentationsEqual(gI,ggI ));");
       ASSUME(0, idealRepresentationsEqual(gI,ggI ));
       ol.writeX("ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));");
       ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));

      ol.writeX( "ASSUME(0, idealsEqual(intersect(I,J),intersect(gI,gJ) ) );");
      ASSUME(0, idealsEqual(intersect(I,J),intersect(gI,gJ) ) );

         ol.writeX("ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,gI) ) );");
      ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,gI) ) );

      ol.writeX("ASSUME(0, idealsAreEqual(intersect(I,J),intersect(gI,gJ) ) );");
      ASSUME(0, idealsAreEqual(intersect(I,J),intersect(gI,gJ) ) );

      ol.writeX("ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,gI) ) );");
      ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,gI) ) );

 */

       trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}


