/////////////////////
version="version test.std";
category="Commutative Algebra";
info="
";

LIB "primdecint.lib";
LIB "randomIdeal.lib";
LIB "ringutils.lib";
LIB "wrappers.lib";
 
proc testMStd( getRng, gens, optionlist, trials, basic, logfile )
{
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
      def rng = getRng( );
      setring rng;
      option(warn);
      
    short = 0;
    int trial;

    while( 1 )
    {   
      option(nowarn);  
      kill rng;      
      def rng = getRng( );
      setring rng;
      ideal cs,  I, J, gI, gJ, ggI, ggJ, mgI,mggI, mgJ,mggJ;
      list lmgI, lmggI;

      if ( hasGlobalOrdering(basering))
      {
         chooseRandomOptionsFromList(optionlist);
      }
      if (warnIsSet)
      {
        option(warn);
      }
      
     
       write(":w "+logfile,emptystring);
       monitor(logfile,"io");
       write(":w "+logfile,emptystring);
       dbprint(1, "LIB \"primdec.lib\";");
       dbprint(1, "LIB \"wrappers.lib\";");
       dbprint(1, "LIB \"src/randomRing.lib\" ;");
       dbprint( 1, "ring rng = "  + string( basering)+";" );
       dbprint( 1, "short = 0 ;" );
       dbprint( 1, "minpoly = " + string(minpoly) + ";");
       dbprint( 1, "intvec op = "+string( option(get) )+";");           
       dbprint( 1, " option(set, op) ;");
       dbprint( 1, " option() ;");
       dbprint( 1, " // option() ;" + option() );
       dbprint( 1, "int trial = " + string( trial) + ";" );
       short = 0;
       I = gens.idealG( );
       dbprint( 1, "system(\"random\", " + string( system("random") ) + ");" );
       dbprint( 1, "ideal I = " + string( I ) + ";" );
       
       dbprint( 1, "       list mgI =  mstd(I);" );
       dbprint( 1, "   gI =  lmgI[1];");
       dbprint( 1, "   mgI =  lmgI[2];");
       lmgI = mstd(I);
       gI =  lmgI[1];
       mgI = lmgI[2];
       //dbprint( 1, "//        gI = "+string(gI) );
       dbprint( 1, "       list lmggI =  mstd(gI);" );
       dbprint( 1, "   ggI =  lmggI[1];");
       dbprint( 1, "   mggI =  lmggI[2];");
       lmggI =  mstd(gI);
       ggI = lmggI[1];
       mggI =  lmggI[2];
       //dbprint( 1, "//        ggI = "+string(ggI) +";");

       dbprint(1, "ASSUME(0, 0== size( std(reduce (I,gI ) ))  );");
       ASSUME(0, 0== size( std(reduce (I,gI ) ))  );

       dbprint(1, "ASSUME(0, 0== size( std(reduce (mgI,gI ) ))  );");
       ASSUME(0, 0== size( std(reduce (mgI,gI ) ))  );

       
       //if ( hasGlobalOrdering(basering))
       //{

       //}
   
       dbprint(1,"ASSUME(0, idealsAreEqual(gI,ggI ));");
       ASSUME(0, idealsAreEqual(gI,ggI ));

       dbprint(1,"ASSUME(0, idealsAreEqual(mggI,ggI ));");
       ASSUME(0, idealsAreEqual(mggI,ggI ));

       
       
       dbprint(1,"ASSUME(0, idealsEqual(gI,ggI ));");
       ASSUME(0, idealsEqual(gI,ggI ));




      if (not (checkRedSB))
      {
         continue;
      }
      //if ( hasGlobalOrdering(basering))
      //{
  
          if ( optionIsSet("redSB") )
          {
 
                dbprint(1,"ASSUME(0, size(gI)== size(ggI) );");
                ASSUME(0, size(gI)== size(ggI) );


                if (not idealRepresentationReducedTail(gI ) )
                {
                   dbprint( 1, "//        gI = "+string(gI) );
                }
                if (not idealRepresentationReducedTail(ggI ) )
                {
                   dbprint( 1, "//        ggI = "+string(ggI) +";");
                }

               dbprint(1,"ASSUME(0, idealRepresentationReducedTail( gI ));");
               ASSUME(0, idealRepresentationReducedTail( gI ));
               dbprint(1,"ASSUME(0, idealRepresentationReducedTail( ggI ));");
               ASSUME(0, idealRepresentationReducedTail( ggI ));
               

               dbprint(1,"ASSUME(0, idealRepresentationReduced( gI ));");
               ASSUME(0, idealRepresentationReduced( gI ));
               dbprint(1,"ASSUME(0, idealRepresentationReduced( ggI ));");
               ASSUME(0, idealRepresentationReduced( ggI ));
          }

      //}


   /*
       dbprint(1,"ASSUME(0, idealRepresentationsEqual(gI,ggI ));");
       ASSUME(0, idealRepresentationsEqual(gI,ggI ));
       dbprint(1,"ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));");
       ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));

    dbprint(1, "ASSUME(0, idealsEqual(intersect(I,J),intersect(gI,gJ) ) );");
      ASSUME(0, idealsEqual(intersect(I,J),intersect(gI,gJ) ) );

         dbprint(1,"ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,gI) ) );");
      ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,gI) ) );

      dbprint(1,"ASSUME(0, idealsAreEqual(intersect(I,J),intersect(gI,gJ) ) );");
      ASSUME(0, idealsAreEqual(intersect(I,J),intersect(gI,gJ) ) );

      dbprint(1,"ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,gI) ) );");
      ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,gI) ) );

 */

       trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}

 

	

