/////////////////////
version="version test.slimgb.correct";
category="Commutative Algebra";
info="
";

LIB "primdecint.lib";
LIB "randomIdeal.lib";
LIB "ringutils.lib";
LIB "wrappers.lib";
 
proc testSlimgb( getRng, idealG, trials )
{

    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
    def rng = getRng( );
    setring rng;
    option(warn);

    int trial;
   
    while( 1 )
    {   
        option(nowarn);  
        kill rng;      

        ol.writeX( " // getRng() ;");

        def rng = getRng( );
        setring rng;  

        if (warnIsSet)      {        option(warn);      }


        ol.writeX( "LIB \"wrappers.lib\";");
        ol.writeX( "LIB \"src/randomRing.lib\" ;");
        ol.writeX( "LIB \"src/tests/test.slimgb.correct\" ;"); 
        ol.writeX(  ringToStringHack (basering) );
        ol.writeX( "int trial = " + string( trial) + ";" );


        I = idealG( );

        ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
        ol.writeX( "ideal I = " + string( I ) + ";" );
        ol.writeX( "  ol.writeX( \"ideal I = \" + string( I ) + \";\" );" );

        ol.writeX( " ideal sI = slimgb(I);  ");
        ol.writeX( " ideal gI = groebner(I); ");
        ideal sI = slimgb(I);
        ideal gI = groebner(I);

        ol.writeX( "   ASSUME(0, idealsAreEqual(sI,gI) );");
        ASSUME(0, idealsAreEqual(sI,gI) );
        trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}

 

	

