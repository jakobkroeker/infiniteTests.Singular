/////////////////////
version="version test.std";
category="Commutative Algebra";
info="
";

LIB "primdecint.lib";
LIB "randomIdeal.lib";
LIB "ringutils.lib";
LIB "wrappers.lib";



/// tests appending a polynomial to existing standard basis
///

proc testGroebnerAppend( getRng, gens, optionlist, trials, basic, finisned, ol )
{
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
      def rng = getRng( );
      setring rng;
      option(warn);
      
    short = 0;
    int trial;

    while( not finisned(trial) )
    {   
      option(nowarn);  
      kill rng;      
      def rng = getRng( );
      setring rng;
      ideal cs,  I, J, I_std,I_plus_J, I_plus_J_std, I_std_append_J_std, I_plus_p, I_plus_p_std, I_std_append_p_std ; 
      poly p ;

      if ( hasGlobalOrdering(basering))
      {
         chooseRandomOptionsFromList(optionlist);
      }
      if (warnIsSet)
      {
        option(warn);
      }
      
      
       if (defined(qrng)) {kill qrng; }
       ol.clearX();
       ol.writeX( "");
       ol.writeX( "");
       ol.writeX( "LIB \"primdec.lib\";");
       ol.writeX( "LIB \"wrappers.lib\";");
       ol.writeX( "LIB \"src/randomRing.lib\" ;");
       ol.writeX(  ringToStringHack (basering) );
       ol.writeX( "int trial = " + string( trial) + ";" );
       short = 0;
       I = gens.idealG( );
       J = gens.idealG( );
       p = gens.polyG();
       ol.writeX( "system(\"random\", " + string( system("random") ) + ");" );
       ol.writeX( "ideal I = " + string( I ) + ";" );
       ol.writeX( "ideal J = " + string( J ) + ";" );
       ol.writeX( "poly p = " + string( p ) + ";" );
       
       ol.writeX( "   ideal I_std   =  std(I);" );
       ol.writeX( "   ideal I_plus_J   = I+J;");
       ol.writeX( "   ideal I_plus_J_std  = std(I_plus_J);");
       ol.writeX( "   ideal I_std_append_J_std = std(I_std,J);");
       ol.writeX( "   ideal I_plus_p   = I+p;");
       ol.writeX( "   ideal I_plus_p_std  = std(I_plus_p);");
       ol.writeX( "   ideal I_std_append_p_std  = std(I_std,p);");

       I_std =  std(I);
       I_plus_J = I+J; // plus_I_J
       I_plus_J_std = std(I_plus_J);  // I_plus_J_std // std_plus_I_J
       I_std_append_J_std= std(I_std,J); // stdI_J_std // std_list_J_stdI //Istd_J_list_std
       I_plus_p = I+p;
       I_plus_p_std  = std(I_plus_p); // I_plus_p_std
       I_std_append_p_std  = std(I_std,p); // I_std_append_p_std 

       ol.writeX( "ASSUME(0, 0== size( std(reduce (I, I_std ) ))  );");
       ASSUME(0, 0== size( std(reduce (I, I_std ) ))  );


       ol.writeX( " ASSUME(0, 0== size( std(reduce (I_plus_J, I_plus_J_std ) ))  ); ");
       ASSUME(0, 0== size( std(reduce (I_plus_J, I_plus_J_std ) ))  );
       ol.writeX( " ASSUME(0, 0== size( std(reduce (I_plus_J, I_std_append_J_std ) ))  );");
       ASSUME(0, 0== size( std(reduce (I_plus_J, I_std_append_J_std ) ))  );
       ol.writeX( "ASSUME(0, 0== size( std(reduce (I_std_append_J_std, I_plus_J_std) ))  ); ");
       ASSUME(0, 0== size( std(reduce (I_std_append_J_std, I_plus_J_std) ))  );
     

       ol.writeX( " ASSUME(0, 0== size( std(reduce (I_plus_p,I_plus_p_std ) ))  ); ");
       ASSUME(0, 0== size( std(reduce (I_plus_p, I_plus_p_std ) ))  );

       ol.writeX( " ASSUME(0, 0== size( std(reduce (I_plus_p,I_std_append_p_std  ) ))  );");
       ASSUME(0, 0== size( std(reduce (I_plus_p, I_std_append_p_std  ) ))  );
       ol.writeX( "ASSUME(0, 0== size( std(reduce (I_std_append_p_std , I_plus_p_std) ))  ); ");
       ASSUME(0, 0== size( std(reduce (I_std_append_p_std , I_plus_p_std) ))  );


       
       //if ( hasGlobalOrdering(basering))
       //{

       ol.writeX("ASSUME(0, idealsEqual(I_std_append_J_std, I_plus_J_std ));");
       ASSUME(0, idealsEqual(I_std_append_J_std, I_plus_J_std ));

       ol.writeX("ASSUME(0, idealsEqual(I_plus_J_std, I_std_append_J_std));");
       ASSUME(0, idealsEqual(I_plus_J_std, I_std_append_J_std ));

      ol.writeX("ASSUME(0, idealsEqual(I_std_append_p_std, I_plus_p_std ));");
       ASSUME(0, idealsEqual(I_std_append_p_std , I_plus_p_std ));

       ol.writeX("ASSUME(0, idealsEqual(I_plus_p_std, I_std_append_p_std ));");
       ASSUME(0, idealsEqual(I_plus_p_std, I_std_append_p_std  ));



       //}

      if (not (checkRedSB))
      {
         continue;
      }
      if ( hasGlobalOrdering(basering))
      {
  
          if ( optionIsSet("redSB") )
          {
 
                ol.writeX("ASSUME(0, size(I_std_append_J_std)== size(I_plus_J_std) );");
                ASSUME(0, size(I_std_append_J_std)== size(I_plus_J_std)  );

                ol.writeX("ASSUME(0, size(I_std_append_p_std )== size(I_plus_p_std) );");
                ASSUME(0, size(I_std_append_p_std )== size(I_plus_p_std)  );



                if (not idealRepresentationReducedTail(I_std ) )
                {
                   ol.writeX( "//        I_std = "+string(I_std) );
                }
                if (not idealRepresentationReducedTail(I_plus_J_std ) )
                {
                   ol.writeX( "//        I_plus_J_std = "+string(I_plus_J_std) +";");
                }
                if (not idealRepresentationReducedTail(I_std_append_J_std ) )
                {
                   ol.writeX( "//        I_std_append_J_std = "+string(I_std_append_J_std) );
                }

                if (not idealRepresentationReducedTail(I_plus_p_std ) )
                {
                   ol.writeX( "//        I_plus_p_std = "+string(I_plus_p_std) +";");
                }
                if (not idealRepresentationReducedTail(I_std_append_p_std  ) )
                {
                   ol.writeX( "//        I_std_append_p_std  = "+string(I_std_append_p_std ) );
                }

 

               ol.writeX("ASSUME(0, idealRepresentationReducedTail( I_std ));");
               ASSUME(0, idealRepresentationReducedTail( I_std ));
               ol.writeX("ASSUME(0, idealRepresentationReducedTail( I_plus_J_std ));");
               ASSUME(0, idealRepresentationReducedTail( I_plus_J_std ));
               
               ol.writeX("ASSUME(0, idealRepresentationReducedTail( I_std_append_J_std ));");
               ASSUME(0, idealRepresentationReducedTail( I_std_append_J_std ));

               ol.writeX("ASSUME(0, idealRepresentationReducedTail( I_plus_p_std ));");
               ASSUME(0, idealRepresentationReducedTail( I_plus_p_std ));
               
               ol.writeX("ASSUME(0, idealRepresentationReducedTail( I_std_append_p_std  ));");
               ASSUME(0, idealRepresentationReducedTail( I_std_append_p_std  ));

            
               ol.writeX("ASSUME(0, idealRepresentationReduced( I_std ));");
               ASSUME(0, idealRepresentationReduced( I_std ));
               ol.writeX("ASSUME(0, idealRepresentationReduced( I_plus_J_std ));");
               ASSUME(0, idealRepresentationReduced( I_plus_J_std ));
               ol.writeX("ASSUME(0, idealRepresentationReduced( I_std_append_J_std ));");
               ASSUME(0, idealRepresentationReduced( I_std_append_J_std ));

               ol.writeX("ASSUME(0, idealRepresentationReduced( I_plus_p_std ));");
               ASSUME(0, idealRepresentationReduced( I_plus_p_std ));
               ol.writeX("ASSUME(0, idealRepresentationReduced( I_std_append_p_std  ));");
               ASSUME(0, idealRepresentationReduced( I_std_append_p_std  ));

 
          }

      }


   /*
       ol.writeX("ASSUME(0, idealRepresentationsEqual(I_std,gI_std ));");
       ASSUME(0, idealRepresentationsEqual(I_std,gI_std ));
       ol.writeX("ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));");
       ASSUME(0, idealRepresentationsEqual(gJ,ggJ ));

    ol.writeX( "ASSUME(0, idealsEqual(intersect(I,J),intersect(I_std,gJ) ) );");
      ASSUME(0, idealsEqual(intersect(I,J),intersect(I_std,gJ) ) );

         ol.writeX("ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,I_std) ) );");
      ASSUME(0, idealsEqual(intersect(J,I),intersect(gJ,I_std) ) );

      ol.writeX("ASSUME(0, idealsAreEqual(intersect(I,J),intersect(I_std,gJ) ) );");
      ASSUME(0, idealsAreEqual(intersect(I,J),intersect(I_std,gJ) ) );

      ol.writeX("ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,I_std) ) );");
      ASSUME(0, idealsAreEqual(intersect(J,I),intersect(gJ,I_std) ) );

 */

       trial = trial+1;
    }

    if ( defined(BAS) ) {  setring BAS; }
    return(1);
}

 

	

