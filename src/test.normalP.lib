/////
version="version test.normal.lib";
category="Commutative Algebra";
info="
";





proc testNormalP( getRandomRing, gens, optionlist, trials, logfile);
{
    int warnIsSet = optionIsSet("warn");
    option(nowarn);
    if (defined(basering) ) {   def BAS=basering; }
    def rng = getRandomRing(gens);
    setring rng;
    option(warn);
      
    short = 0;
    int trial = 0 ;

    int npos;

    intvec v=1,1,1;
 
    def testResult;
    int printlevelOffset = 3 ; // required, since otherwise normal() prints dbinfo because it increases printlevel

    while( trial<trials )
    {   
        option(nowarn);       
      
        kill rng;      
        def rng = getRandomRing(gens);
        setring rng;
        short = 0;
           
       if ( hasGlobalOrdering(basering))
       {
          chooseRandomOptionsFromList(optionlist);
       }
       if (warnIsSet)    {      option(warn);     }
       
       if ( defined(J) ) { kill J; }
       ideal J = gens.idealG();      
       
       if  ( idealsAreEqual(ideal(1), J)   )    {     continue;    }
 
       
       write(":w "+logfile,emptystring);
       monitor(logfile,"io");
       write(":w "+logfile,emptystring);

       dbprint( 1, " intvec testResult; ");
       dbprint( 1, " intvec v=1,1,1;");
       dbprint( 1, "int voiceLvl = "+string(voice)+";");
       
       dbprint( 1, "LIB(\"normal.lib\");");
       dbprint( 1, "LIB(\"src/wrappers.lib\");");
       dbprint( 1, "LIB(\"src/randomRing.lib\");");
       dbprint( 1, "ring rng = "  + string( basering )+";" );
       dbprint( 1, "short = 0 ;" );
       dbprint( 1, "minpoly = " + string(minpoly) + ";");
       dbprint( 1, "intvec op = "+string( option(get) )+";");    
       dbprint( 1, " option(set, op) ;");
       dbprint( 1, " option() ;");
       dbprint( 1,  option() );
       dbprint( 1, "int trial ;" );
       dbprint( 1, "ideal J ="+string(J)+";" );

       dbprint( 1, "def L = primdecGTZ(J);");
       def L = primdecGTZ(J);
       dbprint( 1, "ASSUME(0, testPrimary(L,J) ); ");
       ASSUME(0, testPrimary(L,J) );
       
       dbprint( 1, "ideal component;");

       if ( defined(component) ) { kill component; }
       ideal component;   
      
       if ( defined(normalResult) ) { kill normalResult; }
       dbprint( 1, "list normalResult;");
       list normalResult;
          
       for ( npos=1; npos<=size(L); npos++ )
       {
           dbprint(1, "component   = L["+string(npos)+"][2];");
           component = L[npos][2];

           dbprint(1, string(option()));
           
           dbprint(1, " ASSUME(0, isPrime(component) );" );
           ASSUME(0, isPrime(component) );
 
           if (isPrime(component) && (not isZero(component)) && (not idealsAreEqual(ideal(1),component)) && (not idealsAreEqual(ideal(1),slocus(component) ))  )
           {
               trial = trial+1;
               dbprint(1, "trial = "+string(trial)+";");

               dbprint(1, "normalResult = normalP(component);");
               normalResult = normalP(component,"withRing");
               dbprint(1, " testResult = norTest(component, normalResult);");
               testResult = norTest(component, normalResult);
               dbprint(1, "ASSUME(0, v == norTest(component, normalResult) );");
               ASSUME(0, v == testResult);  
                       
           }
       }
    }


    if (defined(BAS)) {  setring BAS; }
    return(1);
}






