/////////////////////
version="version test.factorize";
category="Commutative Algebra";
info="
";


//LIB "ringutils.lib" ;

LIB "primdec.lib";
LIB "ehv.lib";
//LIB "wrappers.lib" ;
LIB "randomIdeal.lib";



proc reconstructPoly( list l )
{
  int i ;
  poly result=1;

  for(i=1;i<=size(l[1]);i++)
  {
     result = result*(l[1][i])^(l[2][i]);
  }
  return(result);
}

 

proc testFactorize( rng, genTable, trials, logfile )
{
    def polyG = genTable.polyG;
    print ("testFactorize");
    if (defined(basering) ) {   def BAS=basering; }


    setring rng;
    export(rng);

    int trial;
    poly pol;
    list L ;

    while(1)
    {  
      setring rng;
      dbprint(1, "// logfile: "+logfile);
      write(":w "+logfile,emptystring);
      monitor(logfile,"io");
      dbprint(1, "LIB(\"bugs/test.factorize\");");
      dbprint(1, "option(redSB);");
      dbprint(1, "LIB \"primdec.lib\";");
      dbprint(1, "LIB \"wrappers.lib\";");
      dbprint( 1, "ring rng = "  + string( basering)+";" );
      dbprint( 1, "int trial = " + string( trial) + ";" );
       kill pol;    
       poly pol = polyG( );
       if (pol==0) { continue;}
       dbprint( 1, " poly pol = " + string( pol) + ";" );
       kill L;
       list L = factorize(pol);
       dbprint( 1, "list L = factorize(pol);" );
       dbprint( 1, "ASSUME(0, pol==reconstructPoly( L) );" );
       ASSUME(0, pol==reconstructPoly( L) );
       trial = trial + 1;
    }

    if (defined(BAS)) {  setring BAS; }
    return(1);
}



//	printlevel = 0 ;
//    TRACE = 0;

// testFactorizeWrapper("0", "dp");
// testFactorizeWrapper("3", "lp");
// testFactorizeWrapper("23","Dp");



